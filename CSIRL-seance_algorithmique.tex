\documentclass[a4paper]{article}
\usepackage{diffs} %pour les diff de couleur, cf declareuser{user}{color}
\usepackage{authblk}
\usepackage{fullpage}
%\usepackage{multicol}

\usepackage{hyperref} %[pdftex]
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{moreverb,xspace}
\usepackage{color} %for todos
\usepackage{array}
\usepackage{float}
\usepackage{url}
\usepackage{breakurl}
\usepackage[justification=centering]{caption}% or e.g. [format=hang]
\usepackage[version=0.96]{pgf}
\usepackage{verbatim}
\usepackage{amssymb}

%\hyphenation{}

\newcommand{\todo}[1]{\textcolor{red}{#1}}
%ou \fixme{} dans diffs.sty
\newcommand{\titre}[1]{\medskip\noindent\textbf{#1} : }
\newcommand{\illustration}{\titre{Illustration}}
\newcommand{\materiel}{\titre{Matériel}}
\newcommand{\deroulement}{\titre{Déroulement}}
\newcommand{\objectif}{\titre{Objectif}}

\title{Computer science in real life\\ -\\ Science informatique sans ordinateur}

\declareuser{jcb}{jcb}{red}
\declareuser{loic}{loic}{green}
\declareuser{mq}{mq}{blue}

\begin{document}

\date{}

\maketitle

%\begin{abstract}
%Rappel de l'objectif de CSIRL en 2 lignes, + séance en 5 lignes
%\end{abstract}

\section{Introduction}
short intro

\section{Activité : qu'est-ce qu'un algorithme ?}
« $\Rightarrow$ c'est une stratégie gagnante »

\illustration Jeu de Nim\footnote{Les règles du jeu de Nim expliquées sur
Wikipedia : \url{http://fr.wikipedia.org/wiki/Jeu_de_Nim}}

\materiel 16 clous, dont 1 coloré (le clou empoisonné)

\deroulement
\begin{itemize}
\item introduction du jeu de Nim
\begin{itemize}
\item sortie des clous
\item principe : on peut retirer de 1 à 3 clous à la fois
\item le dernier clou est empoisonné
\end{itemize}
\item quelques parties
\item constat du gain à coup sûr
\item explication : "j'ai un truc", une stratégie gagnante (laisser l'adversaire dans une situation à 1 modulo 4 clous - attention, si variante du clou en or, laisser un multiple de 4)
\item trouver une représentation visuelle de la stratégie gagnante : un jeton sur les clous particuliers ? une bande de papier avec la suite de chiffres marqués ?
\item idée de la stratégie gagnante (situation initiale, coups autorisés, méthode pour arriver à une situation finale gagnante)
\end{itemize}

Intérêt en informatique : on peut expliquer une stratégie gagnante, comme en informatique où il faut expliquer à l'ordinateur ce qu'il faut faire.

Introduction des trois caractéristiques d'un ordinateur :
\begin{itemize}
\item rapide
\item fidèle ("il fait tout ce qu'on lui demande")
\item stupide
\end{itemize}
(illustration des deux dernières caractéristiques : il s'éteint lorsqu'on lui demande)

Objectif de cette activité : expliquer pourquoi est-ce qu'un algorithme est important en informatique (rappel : les algorithmes datent de bien avant l'informatique)

$\Rightarrow$ algorithme : situation initiale, modification, situation cible

Le travail de l'informaticien n'est pas de résoudre les problèmes, mais de comprendre suffisamment pour l'expliquer à un "crétin fini".
Travail de l'informaticien = travail de fainéant : l'informaticien est capable de réfléchir longtemps pour ne plus réfléchir après.




\section{Activité : le crêpier psycho-rigide}
\materiel des planchettes en bois de tailles et de couleurs différentes (faces reconnaissables), éventuellement une pelle à tarte pour retourner les planchettes

\deroulement
\begin{itemize}
\item présentation de la situation
\begin{itemize}
\item le crêpier a fait des crêpes
\item elles ne sont malheureusement pas bien rangées ! petites et grandes sont mélangées, et on voit la face un peu brûlée de certaines crêpes !
\item inacceptable !
\item on décide de l'aider à les ranger
\item problème : il n'a qu'une seule assiette et sa pelle à tarte
\end{itemize}
\item présentation des coups autorisés :
\begin{itemize}

\item on prend une ou plusieurs crêpes en haut de la pile et on retourne le
tout d'un coup

\item attention vous ne serez pas toujours là pour aider le crêpier. Il ne
s'agit pas de trier ses crêpes mais de lui montrer comment trier ses crêpes

\end{itemize}
\item faire tester à quelqu'un
\begin{itemize}

\item "tentez de résoudre ce problème intuitivement, on réfléchira après"

\item si la personne bloque, lui donner un conseil : "une bonne première étape
est de se débrouiller pour mettre la grande en bas"

\item si ça ne passe pas, aider ("où est-ce que la grande devrait être pour
pouvoir la mettre en bas") et donner le conseil pour l'étape suivante (guide
pas-à-pas)

\item faire verbaliser l'algorithme au cobaye

\end{itemize}

\item Voir aussi :
\url{http://interstices.info/jcms/n_52318/genese-dun-algorithme?hlText=cr%C3%A8pes}
(mais c'est vachement moins IRL)

\end{itemize}

$\Rightarrow$ L'algorithme est quelque chose de suffisamment simple pour
pouvoir l'expliquer à un imbécile (référence à l'activité précédente)



\section{Activité : baseball multicolore}
\materiel 6 ensembles de Lego de couleurs différentes, chaque ensemble est composé de 3 pièces : une de 4 (la maison) et deux de 2 (les bonhommes)

\deroulement
\begin{itemize}
\item Situation initiale - disposition
\begin{itemize}
\item on dépose les maisons aux 4 coins du terrain
\item on retire un bonhomme quelconque du jeu
\item on mélange les bonhommes et on place 2 bonhommes au hasard sur chaque maison (sauf une). On essaiera de ne pas mettre directement les bonhommes sur leurs maisons
\end{itemize}
\item Objectif : tous les bonhommes veulent rentrer à la maison (celle de leur couleur)
\item Coups autorisés :
\begin{itemize}
\item un seul bonhomme peut bouger à la fois
\item il ne peut pas y avoir plus de 2 bonhommes par maison
\item un bonhomme ne peut se déplacer que vers l'une des deux maisons voisines de celle où il est
\item Note : les joueurs font moins de fautes de jeu en n'utilisant qu'une seule main et un seul doigt
\end{itemize}
\item on demande d'abord aux spectateurs de faire rentrer les bonhommes intuitivement
\item on demande aux spectateurs d'expliquer comment ils ont fait $\Rightarrow$ 2 cas :
\begin{itemize}
\item ils y arrivent et on ajoute des couleurs
\item ça bloque et il faut les aider : on pose une pièce avec une flèche qui indique un sens de rotation, une nouvelle couleur et on propose un algorithme (qui se révélera faux)
\begin{itemize}
\item sens donné par la pièce
\item à chaque étape, la maison de destination est imposée (celle où il y a trou, donc il faut choisir quel bonhomme bouger)
\item on se fixe comme règle : faire bouger le bonhomme le plus loin
\item on réitère
\end{itemize}
\item on leur fait faire tourner l'algorithme
\item ça converge (très souvent) vers la situation finale
\item "c'est bien : c'est simple, c'est assez rapide, c'est élégant... mais faux !". On prend une situation convergente, et on inverse deux pions non adjacents. Et maintenant ?
\item on constate que ça ne converge plus, car il faudrait qu'une pièce double l'autre. Impossible !
\item donc ce n'est pas un bon algorithme : on a l'impression qu'il fonctionne, mais on arrive à trouver des contre-exemples
\item c'est là qu'on comprend l'intérêt des chercheurs en informatiques : trouver l'algorithme et prouver que l'algorithme est correct (comment ? avec des maths. attention, c'est compliqué)
\item on va chercher le bon algorithme. On change la disposition du plateau : on dispose les pions en ligne et on peut même ajouter d'autres couleurs. On respecte bien toujours les règles, on s'est même interdit de faire quelque chose d'autorisé par les règles. Note : pour la suite c'est mieux que la couleur à un seul bonhomme se situe à une extrémité.
\begin{itemize}
\item on se fixe des objectifs intermédiaires comme lors de l'activité du crêpier psycho-rigide : on veut amener les pions de la couleur de l'extrémité
\item mécanisme : [schémas ou photos ou vidéo]
\item on peut se poser la question de performance : c'est lors des choix que l'on peut améliorer les performances. Soit on fait au hasard, soit on choisit de déplacer le pion le plus éloigné
\item on fait tourner l'algorithme jusqu'à ce que le participant soit convaincu qu'il fonctionne
\item question de la correction de cet algorithme :
\item et si c'était encore un algorithme incorrect ? Non, c'est un algorithme connu, que l'on apprend au deuxième cours d'algorithmique.
\item analogie informaticien/musicien : le musicien fait ses gammes, l'informaticien apprend par c\oe{}ur des algorithmes
\item lorsque l'on soumet un problème à un informaticien, il essaie de se raccrocher à des problèmes qu'il connait (ex. du cas du crêpier : est-ce les tours de Hanoï ? Non, l'histoire ressemble mais la résolution est totalement différente)
\end{itemize}
\end{itemize}
\end{itemize}

Debrief :
\begin{itemize}
\item travail du programmeur = se faire obéir par des tas de fils. Méthode = apprendre des algorithmes abstraits qu'ils appliquer aux problèmes qu'ils rencontrent. le principe de la décomposition en sous-problèmes plus simples = grand classique souvent gagnant.
\item qualité d'un algorithme = performance et correction.
\item métier de certains chercheurs en informatique = inventer de nouveaux algorithmes, étudier la correction des algorithmes et leurs performances
\end{itemize}



\section{Activité : le plus court chemin}

\materiel une planche avec des trous bien verticaux dedans, des clous du
même diamètre qu'on rentre dans chaque trou (la pointe en bas); une corde
blanche et un marqueur.

\deroulement
\begin{itemize}
\item Étape 1 : le participant a 1mn pour comprendre la consigne et faire faire
un chemin à sa ficelle qui passe par toutes les vis une fois unique, et qui
boucle.
\item Étape 2 : on refait sans limite de temps. Sur la ficelle sont marquée les
différentes longueurs record. Si le participant fait plus court, on fait un
trait au marqueur sur la longueur obtenue.
\begin{itemize}
\item La discussion après l'étape 2 est qu'en beaucoup plus de temps, on a
trouvé une solution marginalement meilleure.
\item On peut aussi évoquer à quoi ressemblerait l'algo exact et sa complexité,
mais c'est pas central pour l'activité. D'autant qu'il est tellement con qu'il
n'est pas facile de convaincre qu'il n'en existe pas de meilleur. On peut
déplier les différents algos tentants et faux connus si on a peur de s'ennuyer
(\url{http://www.loria.fr/~quinson/Teaching/TOP/TOP-handout.pdf pages
120-123}). Mais bon, c'est probablement déroutant pour les participants de se
trouver face à face avec un problème ouvert...

\item En fait la discussion est plutôt sur les heuristiques, avec un message de
la forme "trouver la solution optimale est parfois très dur, alors qu'on peut
trouver un truc pas trop con très vite -- ce n'est plus un algo mais une
heuristique".
\item Une fois qu'en est là, il est tentant de parler des problèmes où il faut
déployer les heuristiques car on ne connait pas d'algo efficace. Pour ça, les
problèmes NP sont quand même de supers candidats. Pour rappel, NP veut dire
"Non-deterministic Polynomial", et c'est une classe de problèmes où on ne
connait pas d'algorithme polynomial pour trouver des solutions, mais vérifier
qu'une solution est correcte prend un temps polynomial. C'est le cas du
voyageur de commerce, le problème dont on s'inspire ici : quand la question est
"est-ce qu'il existe un chemin de longueur N ou moins?" et si on me propose un
chemin donné, je peux bien vérifier en temps polynomial si sa longueur totale
respecte les contraintes données.
\item Et une fois que t'as réussi à faire entrevoir ceci à un néophyte, ce
serait malice de ne pas parler du problème phare de l'informatique: P=NP. Le
problème à 1M\$, qui protège ta carte bleue. La question est de savoir si P =
NP ou pas. Autrement dit, s'il existe un algo polynomial pour les problèmes NP.
Pour l'instant, personne n'en a trouvé, mais personne n'a réussi à démontrer
qu'il n'en existe pas, non plus. Pour prouver que P != NP, il faudrait trouver
un problème pour lequel on démontre qu'il n'existe pas d'algo P pour le
résoudre, mais dont les solutions sont vérifiables en temps polynomial.
\item On a alors envie de parler de NP-complétude, mais c'est un peu difficile.
L'idée est que les informaticiens classifient les problèmes qu'ils n'arrivent
pas à résoudre selon la difficulté de les résoudre. C'est un peu tordu car on
réfléchit à ce qu'on gagnerait à savoir faire des trucs impossibles pour
l'instant, mais bon. On regarde si on saurait résoudre un problème impossible
avec la solution d'un autre problème impossible. C'est comme si on se posait
des questions comme "et si je savais voler, est-ce que je pourrais résoudre de
la famine dans le monde? Par ailleurs, si je savais résoudre la famine dans le
monde, est-ce que je saurais voler?". Certains chercheurs en informatique sont
payés pour répondre à ce genre de question, avec juste un peu d'enrobage
mathématique pour éviter les questions embarrassantes des passants :)
\item On peut passer par l'introduction des problèmes NP-difficiles. On peut
voir leurs solutions comme des outils sur-puissants, qui seraient capable de
résoudre tous les problèmes NP si on savait construire ces solutions. Ce sont
donc d'une certaine façon des problèmes au moins aussi durs que les NP, voire
plus durs pour certains d'entre eux.
\item Fait amusant, certains de ces outils sur-puissants (NP-difficiles) sont
eux-même des problèmes NP. On dit qu'ils sont NP-complets. Ils sont donc à la
fois NP (on ne sait pas les résoudre en temps polynomial, mais on sait
reconnaitre qu'une solution est la bonne ou non en temps polynomial) et
NP-difficile (si on savait les résoudre, on saurait résoudre tous les problèmes
NP). Le schéma en haut de \url{http://en.wikipedia.org/wiki/NP-complete} est
pas mal pour aider à se repérer. Une conclusion amusante de cette double
appartenance est qu'ils sont à la fois outils permettant de résoudre les NP, et
problèmes qu'on peut résoudre avec un tel outil. Ça serait vraiment bien de
faire sentir aux participants cette histoire d'équivalence de complexité entre
tous ces problèmes, mais c'est pas forcément simple.
\item Pour aller plus loin
\begin{itemize}
\item Si la question d'un exemple de problème NP-difficile qui ne soit pas NP
(et pour lequel on ait pas de variante NP), on peut citer le jeu d'échec,
puisque trouver une stratégie gagnante est un problème reconnu exponentiel. Il
y a même une classe de complexité pour cela: EXPTIME.
\item Le consensus entre les informaticiens, c'est que P != NP, même si c'est
une simple supposition. La raison de ce sentiment, c'est qu'il suffirait de
trouver un algo polynomial pour n'importe lequel des problèmes NP-complet pour
montrer que P=NP. Et beaucoup de gens brillants essayent depuis longtemps, en
vain. Mais ce n'est qu'une supposition, rien n'est sûr.
\end{itemize}
\item Pour revenir au problème des clous,
\item la question "trouver le plus court chemin" est NP-difficile et pas NP.
Quand on me donne une solution, je peux pas vérifier simplement si c'est la
plus courte.
\item La question "est-ce qu'il existe une solution de longueur inférieure à k"
est NP car on ne connait pas d'algo polynomial pour répondre, mais quand on me
propose une solution, je peux vérifier sa longueur facilement. Et par ailleurs,
on a fait toutes les réductions qui vont bien pour montrer que ce problème est
NP-complet (le schéma de
\url{http://en.wikipedia.org/wiki/NP-complete#NP-complete_problems} est bien)
\end{itemize}
\item Autre exemple simpliste de réduction: c'est en général plus dur pour de
faire une division à la main que de vérifier que la solution d'une division est
correcte en multipliant les opérandes. On a donc une sorte de classification de
la complexité des problèmes, même si l'exemple est un peu mou car on n'a pas
quantifié proprement la complexité de résolution dans ce cas. Il n'empêche, ça
peut faire un exemple un peu "avec les mains" à utiliser pour faire saisir le
sens général à l'auditoire.
\end{itemize}

\end{document}
